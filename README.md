# JShorts

 
##### _короткие записи часто используемых кейсов на >=ES6 синтаксисе_

```js
/* -= 1 =-
    Тернарный оператор */

const num = 42;

// Классический вариант
let result;
if (num > 20) {
    result = 'More then 20';
} else {
    result = 'Less then 20';
}
console.log(result); // More then 20

// Сокращенный вариант

// let переменная = условие ? если true : если false;
let result = num > 20 ? 'More then 20' : 'Less then 20';
console.log(result); // More then 20

// ============================================================================/

/* -= 2 =-
    Проверка на существование переменной и присвоение ей определенного значения */

let variable1, // undefined - такое значение имеет неинициализированная переменная
    variable2;

// Классический вариант
if (variable1 !== null
        && variable1 !== undefined
        && variable1 !== false
        && variable1 !== '') {
    variable2 = variable1;
} else {
    variable2 = 'some value';
}
console.log(variable2); // some value

/* Info:
   Простое условие if (variable) охватывает проверку на неравенство сразу 4-х условий:
   null, undefined, false, '' (пустая строка) - все эти варианты возвращают false. */

// Сокращенный вариант

/* Если в переменной variable есть какое-либо значение отличное от false, то
   присваивается ее значение, если нет, то значение по умолчанию - 'some value' */
variable2 = variable1 || 'some value';
console.log(variable2); // some value

// ============================================================================/

/* -= 3 -=
    Объвление переменных в одну строку */

// Классический вариант
let x = 0;
let y;
let z = 42;

// Сокращенный вариант
let x = 0, y, z = 42;

// ============================================================================/

/* -= 4 =-
    Проверка на true/false */

// Классический вариант
const isSame = true;
if (isSame === true) { /* code */ }
if (isSame !== true) { /* code */ }

// Сокращенный вариант
if (isSame) { /* code */ }  // true
if (!isSame) { /* code */ } // false

// ============================================================================/

/* -= 5 =-
    Итерация массивов */

let names = ['John', 'Dow', 'Smitt'];

// Классический вариант
for (let i = 0; i < names.length; i++) {
    console.log(names[i]);  // John
                            // Dow
                            // Smitt
}

// Сокращенный вариант

// Вывод только значений без индексов
for (let name of names) {
    console.log(name);  // John
                        // Dow
                        // Smitt
}

// Вывод с индексами
for (let index in names) {
    // вывод и индексов и значений массива
    console.log(index, names[index]);   // 0 John
                                        // 1 Dow
                                        // 2 Smitt
}

// Нативные функции для массивов
/* Колбэк функция может принимать 3 параметра:
    - значение элемента массива,
    - его индекс,
    - ссылка на сам итерируемый массив */
names.forEach(function(arrayElement, index, array) {
    console.log(`names[${index}] - ${arrayElement}`);   // names[0] - John
                                                        // names[1] - Dow
                                                        // names[2] - Smitt
});

// ============================================================================/

/* -= 6 =-
    Инициализация переменных и значения по умолчанию (см. 2-й кейс) */

// Классический вариант
let port;
if (process.env.PORT) {
    port = process.env.PORT;
} else {
    port = 4200;
}

// Сокращенный вариант
/* Если переменная process.env.PORT проинициализирована и имеет значение, то ее
    значение присваивается переменной port, если нет, то присваивается значение
    по умолчанию - 4200 */
const port = process.env.PORT || 4200;

// ============================================================================/

/* -= 7 =-
    Цикл с большим числом итераций */

// Классический вариант
for (let i = 0; i < 1000000; i++) { /* code */ }

// Сокращенный вариант
for (let i = 0; i < 10e6; i++) { /* code */ }
/* т.е. запись числа представлена в экспоненциальном виде (научной нотации - MEp),
    где число умноженное на 10 в степени 6 */

// ============================================================================/

/* -= 8 =-
    Присвоение свойствам обекта переменных, имена которых совпадают с именами свойств объекта, позволяет сократить код */

let a = 1, b = 2;

// Классический вариант
let myObj = {
    a: a,
    b: b
};

// Сокращенный вариант
let myObj = { a, b };

// ============================================================================/

/* -= 9 =-
    Стрелочные функции */

// Классический вариант
setTimeout(function() {
    console.log('After 2 sec');
}, 2000);

function triple(num) {
    return num * 3;
}
// Сокращенный вариант
setTimeout(() => console.log('After 2 sec'), 2000);

const triple = (num) => { return num * 3 };
/* или, если аргумент один и возвращаемое выражение одно и все в одну строку,
    то ни ключевое слово return и скобки можно опустить: */
const triple = num => num * 3;

// ============================================================================/

/* -= 10 =-
    Аргументы по умолчанию + стрелочная функция */

// Классический вариант
function rgb(r, g, b) {
    if (r === undefined) {
        r = 0;
    }

    if (g === undefined) {
        g = 255;
    }

    if (b === undefined) {
        b = 105;
    }

    return 'rgb(' + r + ', ' + g + ', ' + b + ');';
}

// Сокращенный вариант
const rgb = (r = 0, g = 255, b = 105) => `rgb(${r}, ${g}, ${b});`;

// ============================================================================/

/* 11
    Строковые литералы */

// Классический вариант
function createURL(base, domain) {
    return 'http://' + base + '.' + domain;
}

// Сокращенный вариант
function createURL(base, domain) {
    return `http://${base}.${domain}`;
}

// ============================================================================/

/* -= 12 =-
    Деструктуризация */

// Классический вариант
const alert = window.alert;
const confirm = window.confirm;
const prompt = window.prompt;

// Сокращенный вариант
/* Выделение в отдельные переменные из методов объекта.
    Что-то похожее есть в PHP: extract(['var1' => 'val1', 'var2' => 'val2']); */
const { alert, confirm, prompt } = window;

// ============================================================================/

// 13
// Спред (spread) оператор для массивов

let arr = [1, 2, 3];
let nums = [4, 5, 6];

// Классический вариант
// Соединение массивов
let nums = [4, 5, 6].concat(arr); // [ 4, 5, 6, 1, 2, 3 ]
// Клонирование массива
let cloned = nums.concat(); // новый массив, не ссылка на nums

// Сокращенный вариант
let nums = [4, ...arr, 5, 6]; // [ 4, 1, 2, 3, 5, 6 ]
let nums = [4, 5, 6, ...arr]; // [ 4, 5, 6, 1, 2, 3 ]
let cloned = [...nums]; // новый массив, не ссылка на nums

// ============================================================================/

/* -= 14 =-
    Математическое округление в нижнюю сторону */

// Классический вариант
console.log(Math.floor(9.7) === 9); // true

// Сокращенный вариант
console.log(~~9.7 === 9); // true

// ============================================================================/

/* -= 15 =-
    Возведение в степень */

// Классический вариант
console.log(Math.pow(2, 2)); // 4
console.log(Math.pow(2, 3)); // 8
console.log(Math.pow(4, 3)); // 64

// Сокращенный вариант
console.log(2 ** 2); // 4
console.log(2 ** 3); // 8
console.log(4 ** 3); // 64

// ============================================================================/

/* -= 16 =-
    Конвертация строки в число */

// Классический вариант
const num = parseInt('42');
const float = parseFloat('42.42');

// Сокращенный вариант
const num = +'42';
const float = +'42.42';

console.log(typeof num, typeof float); // number number

// ============================================================================/

/* -= 17 =-
    Поиск значения в массиве */

let arrs = [1, 2, 3, 4, 'test'];

// Классический вариант

// Метод indexOf() возвращает -1, если элемент не был найден
if (arrs.indexOf('test') > -1) { console.log('Found!'); }

// Сокращенный вариант

// Побитовый оператор ~ (тильда) возвращает true, если не -1
if (~arrs.indexOf('test')) { console.log('Found!'); }

// !~ - обратно инвертирует true в false
if (!~arrs.indexOf('test')) { console.log('Found!'); }

// Метод includes() сразу возвращает true или false
if (arrs.includes('test')) { console.log('Found!'); }

// ============================================================================/

/* -= 18 =-
    Конвертация объекта в массив */

const car = {
    model: 'Ford',
    year: '1975',
    color: 'red'
};

// Конвертация в масив ключей и значений
console.log(Object.entries(car));   // [
                                    //      [ 'model', 'Ford' ],
                                    //      [ 'year', '1975' ],
                                    //      [ 'color', 'red' ]
                                    // ]


// Вывод только значений
console.log(Object.values(car)); // [ 'Ford', '1975', 'red' ]

// Вывод только ключей
console.log(Object.keys(car)); // [ 'model', 'year', 'color' ]

// ============================================================================/
```